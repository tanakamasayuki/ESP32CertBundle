#!/usr/bin/env python3
"""Fetch and convert the ESP-IDF X.509 bundle into an Arduino header."""

from __future__ import annotations

import argparse
import datetime as _dt
import pathlib
import subprocess
import sys
import urllib.request


GEN_SCRIPT_URL = "https://raw.githubusercontent.com/espressif/esp-idf/master/components/mbedtls/esp_crt_bundle/gen_crt_bundle.py"
CACERT_URL = "https://curl.se/ca/cacert.pem"


def download(url: str, dest: pathlib.Path, force: bool = False) -> None:
    if dest.exists() and not force:
        return
    with urllib.request.urlopen(url) as response:
        data = response.read()
    dest.write_bytes(data)


def run_gen_script(gen_script: pathlib.Path, cacert: pathlib.Path, workdir: pathlib.Path) -> pathlib.Path:
    args = [sys.executable, str(gen_script), "-i", str(cacert)]
    subprocess.run(args, check=True, cwd=workdir)
    candidates = [
        workdir / "x509_crt_bundle.bin",
        workdir / "x509_crt_bundle",
    ]
    for candidate in candidates:
        if candidate.exists():
            if candidate.suffix != ".bin":
                target = candidate.with_suffix(".bin")
                candidate.replace(target)
                return target
            return candidate
    raise FileNotFoundError("x509_crt_bundle(.bin) was not created by gen_crt_bundle.py")


def format_as_c_array(data: bytes) -> str:
    hex_bytes = [f"0x{b:02x}" for b in data]
    lines = []
    for i in range(0, len(hex_bytes), 16):
        chunk = ", ".join(hex_bytes[i : i + 16])
        lines.append(f"    {chunk}")
    return ",\n".join(lines)


def write_header(bin_path: pathlib.Path, header_path: pathlib.Path) -> None:
    data = bin_path.read_bytes()
    header_path.parent.mkdir(parents=True, exist_ok=True)
    c_array = format_as_c_array(data)
    timestamp = _dt.datetime.now(_dt.timezone.utc).isoformat(timespec="seconds")
    header_lines = [
        f"// This file is auto-generated by tools/update_bundle.py on {timestamp}",
        f"// Source bundle: {CACERT_URL}",
        "",
        "#pragma once",
        "",
        "#include <pgmspace.h>",
        "#include <stddef.h>",
        "",
        "static const unsigned char x509_crt_bundle[] PROGMEM = {",
        f"{c_array}",
        "};",
        "",
        "static const unsigned int x509_crt_bundle_len = sizeof(x509_crt_bundle);",
        "",
    ]
    header_path.write_text("\n".join(header_lines), encoding="utf-8")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--force-download",
        action="store_true",
        help="Re-download helper scripts even if cached versions exist.",
    )
    parser.add_argument(
        "--cacert-url",
        default=CACERT_URL,
        help="Override the source CA bundle URL.",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    repo_root = pathlib.Path(__file__).resolve().parents[1]
    cache_dir = repo_root / "tools" / "cache"
    cache_dir.mkdir(parents=True, exist_ok=True)

    gen_script = cache_dir / "gen_crt_bundle.py"
    cacert = cache_dir / "cacert.pem"

    download(GEN_SCRIPT_URL, gen_script, force=args.force_download)
    download(args.cacert_url, cacert, force=args.force_download)

    bundle_bin = run_gen_script(gen_script, cacert, cache_dir)
    header_path = repo_root / "src" / "esp32_cert_bundle.h"
    write_header(bundle_bin, header_path)


if __name__ == "__main__":
    main()
